/**

Copyright 2024 F5, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

**/

package data_collector

import (
	"archive/tar"
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"time"

	helmClient "github.com/mittwald/go-helm-client"
	"github.com/nginxinc/nginx-k8s-supportpkg/pkg/crds"
	corev1 "k8s.io/api/core/v1"
	crdClient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/tools/remotecommand"
	"k8s.io/client-go/util/homedir"
	metricsClient "k8s.io/metrics/pkg/client/clientset/versioned"
)

type DataCollector struct {
	BaseDir               string
	Namespaces            []string
	Logger                *log.Logger
	LogFile               *os.File
	K8sRestConfig         *rest.Config
	K8sCoreClientSet      *kubernetes.Clientset
	K8sCrdClientSet       *crdClient.Clientset
	K8sMetricsClientSet   *metricsClient.Clientset
	K8sHelmClientSet      map[string]helmClient.Client
	ExcludeDBData         bool
	ExcludeTimeSeriesData bool
}

type Manifest struct {
	Version      string        `json:"version"`
	Timestamp    TimestampInfo `json:"ts"`
	PackageType  string        `json:"package_type"`
	RootDir      string        `json:"root_dir,omitempty"`
	Commands     []Command     `json:"commands,omitempty"`
	ProductInfo  ProductInfo   `json:"product_info"`
	PlatformInfo PlatformInfo  `json:"platform_info"`
	Packages     []SubPackage  `json:"packages,omitempty"`
}

type TimestampInfo struct {
	Start string `json:"start"`
	Stop  string `json:"stop"`
}

type Command struct {
	Name    string        `json:"name"`
	Cwd     string        `json:"cwd"`
	Ts      CommandTiming `json:"ts"`
	Output  string        `json:"output"`
	RetCode int           `json:"retcode,omitempty"`
}

type CommandTiming struct {
	Start string `json:"start"`
	End   string `json:"end"`
}

type ProductInfo struct {
	Product string `json:"product"`
	Version string `json:"version"`
	Build   string `json:"build"`
}

type PlatformInfo struct {
	// Add platform-specific fields as needed
	PlatformType string `json:"platform_type,omitempty"`
	Hostname     string `json:"hostname,omitempty"`
	SerialNumber string `json:"serial_number,omitempty"`
}

type SubPackage struct {
	Path           string        `json:"path"`
	Ts             TimestampInfo `json:"ts"`
	SubPackageType string        `json:"sub_package_type"`
	Name           string        `json:"name,omitempty"`
	ID             string        `json:"id,omitempty"`
}

type JobInfo struct {
	Name      string   `json:"name"`
	StartTime string   `json:"start_time"`
	EndTime   string   `json:"end_time"`
	Duration  string   `json:"duration"`
	Status    string   `json:"status"` // "completed", "failed", "skipped"
	Error     string   `json:"error,omitempty"`
	Files     []string `json:"files,omitempty"` // List of files generated by the job
}

func NewDataCollector(collector *DataCollector) error {

	tmpDir, err := os.MkdirTemp("", "-pkg-diag")
	if err != nil {
		return fmt.Errorf("unable to create temp directory: %s", err)
	}

	logFile, err := os.OpenFile(filepath.Join(tmpDir, "supportpkg.log"), os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("unable to create log file: %s", err)
	}

	// Find config
	kubeConfig := os.Getenv("KUBECONFIG")
	if kubeConfig == "" {
		kubeConfig = filepath.Join(homedir.HomeDir(), ".kube", "config")
	}
	config, err := clientcmd.BuildConfigFromFlags("", kubeConfig)

	if err != nil {
		return fmt.Errorf("unable to connect to k8s using file %s: %s", kubeConfig, err)
	}
	// Set up the DataCollector options
	collector.BaseDir = tmpDir
	collector.LogFile = logFile
	collector.Logger = log.New(logFile, "", log.LstdFlags|log.LUTC|log.Lmicroseconds|log.Lshortfile)
	collector.K8sHelmClientSet = make(map[string]helmClient.Client)

	//Initialize clients
	collector.K8sRestConfig = config
	collector.K8sCoreClientSet, _ = kubernetes.NewForConfig(config)
	collector.K8sCrdClientSet, _ = crdClient.NewForConfig(config)
	collector.K8sMetricsClientSet, _ = metricsClient.NewForConfig(config)
	for _, namespace := range collector.Namespaces {
		collector.K8sHelmClientSet[namespace], _ = helmClient.NewClientFromRestConf(&helmClient.RestConfClientOptions{
			Options:    &helmClient.Options{Namespace: namespace},
			RestConfig: config,
		})
	}

	return nil
}

func (c *DataCollector) WrapUp(product string) (string, error) {

	unixTime := time.Now().Unix()
	unixTimeString := strconv.FormatInt(unixTime, 10)
	tarballName := fmt.Sprintf("%s-supportpkg-%s.tar.gz", product, unixTimeString)
	tarballRootDirName := "."

	err := c.LogFile.Close()
	if err != nil {
		return tarballName, err
	}

	file, err := os.Create(tarballName)
	if err != nil {
		return tarballName, err
	}
	defer func(file *os.File) {
		cerr := file.Close()
		if cerr == nil {
			err = cerr
		} else {
			c.Logger.Printf("error closing file %s, %v", file.Name(), cerr)
		}
	}(file)

	gw := gzip.NewWriter(file)
	defer func(gw *gzip.Writer) {
		cerr := gw.Close()
		if cerr == nil {
			err = cerr
		} else {
			c.Logger.Printf("error closing gzip writer, %v", cerr)
		}
	}(gw)

	tw := tar.NewWriter(gw)
	defer func(tw *tar.Writer) {
		cerr := tw.Close()
		if cerr == nil {
			err = cerr
		} else {
			c.Logger.Printf("error closing tar writer, %v", cerr)
		}
	}(tw)

	err = filepath.Walk(c.BaseDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		header, err := tar.FileInfoHeader(info, "")
		if err != nil {
			return err
		}

		relativePath, err := filepath.Rel(c.BaseDir, path)
		if err != nil {
			return err
		}
		header.Name = filepath.ToSlash(filepath.Join(tarballRootDirName, relativePath))

		if err = tw.WriteHeader(header); err != nil {
			return err
		}

		if !info.Mode().IsRegular() {
			return nil
		}

		file, err = os.Open(path)
		if err != nil {
			return err
		}
		defer func(file *os.File) {
			cerr := file.Close()
			if cerr == nil {
				err = cerr
			} else {
				c.Logger.Printf("error closing file %s, %v", file.Name(), cerr)
			}
		}(file)

		_, err = io.Copy(tw, file)
		if err != nil {
			return err
		}

		return nil
	})
	if err != nil {
		return tarballName, err
	}
	_ = os.RemoveAll(c.BaseDir)
	return tarballName, nil
}

func (c *DataCollector) PodExecutor(namespace string, pod string, container string, command []string, ctx context.Context) ([]byte, error) {
	req := c.K8sCoreClientSet.CoreV1().RESTClient().Post().
		Namespace(namespace).
		Resource("pods").
		Name(pod).
		SubResource("exec").
		VersionedParams(&corev1.PodExecOptions{
			Command:   command,
			Container: container,
			Stdin:     false,
			Stdout:    true,
			Stderr:    true,
			TTY:       true,
		}, scheme.ParameterCodec)

	exec, err := remotecommand.NewSPDYExecutor(c.K8sRestConfig, "POST", req.URL())
	if err != nil {
		return nil, err
	}
	var stdout, stderr bytes.Buffer
	err = exec.StreamWithContext(ctx, remotecommand.StreamOptions{
		Stdin:  nil,
		Stdout: &stdout,
		Stderr: &stderr,
	})
	if stdout.Len() > 0 || stderr.Len() > 0 {
		response := append(stdout.Bytes(), stderr.Bytes()...)
		return response, nil
	} else {
		return nil, err
	}
}

func (c *DataCollector) QueryCRD(crd crds.Crd, namespace string, ctx context.Context) ([]byte, error) {

	schemeGroupVersion := schema.GroupVersion{Group: crd.Group, Version: crd.Version}
	negotiatedSerializer := scheme.Codecs.WithoutConversion()
	c.K8sRestConfig.APIPath = "apis"
	c.K8sRestConfig.GroupVersion = &schemeGroupVersion
	c.K8sRestConfig.NegotiatedSerializer = negotiatedSerializer

	client, err := rest.RESTClientFor(c.K8sRestConfig)
	if err != nil {
		return nil, err
	}

	result := client.Get().
		Namespace(namespace). // Specify the namespace if needed
		Resource(crd.Resource).
		Do(ctx)

	return result.Raw()
}

func (c *DataCollector) AllNamespacesExist() bool {
	var allExist = true
	for _, namespace := range c.Namespaces {
		_, err := c.K8sCoreClientSet.CoreV1().Namespaces().Get(context.TODO(), namespace, metav1.GetOptions{})
		if err != nil {
			c.Logger.Printf("\t%s: %v\n", namespace, err)
			fmt.Printf("\t%s: %v\n", namespace, err)
			allExist = false
		}
	}

	return allExist
}

func (c *DataCollector) GenerateManifest(product string, startTime time.Time, jobsRun, jobsFailed int, jobTimings []JobInfo) ([]byte, error) {
	// Read and parse product_info.json
	filename := filepath.Join(c.BaseDir, "product_info.json")
	file, err := os.Open(filename)
	var info ProductInfo
	if err != nil {
		c.Logger.Printf("Warning: failed to open product_info.json: %v. Using default values.", err)
	} else {
		defer file.Close()
		decoder := json.NewDecoder(file)
		if err := decoder.Decode(&info); err != nil {
			c.Logger.Printf("Warning: failed to decode product_info.json: %v. Using default values.", err)
		}
	}

	filename = filepath.Join(c.BaseDir, "platform_info.json")
	file, err = os.Open(filename)
	var platformInfo PlatformInfo
	if err != nil {
		c.Logger.Printf("Warning: failed to open platform_info.json: %v. Using default values.", err)
	} else {
		defer file.Close()
		decoder = json.NewDecoder(file)
		if err = decoder.Decode(&platformInfo); err != nil {
			c.Logger.Printf("Warning: failed to decode platform_info.json: %v. Using default values.", err)
		}
	}
	manifest := Manifest{
		Version: "1.2", // Match the schema version
		Timestamp: TimestampInfo{
			Start: startTime.UTC().Format(time.RFC3339Nano),
			Stop:  time.Now().UTC().Format(time.RFC3339Nano),
		},
		PackageType:  "root", // As defined in schema enum
		RootDir:      ".",
		ProductInfo:  info,
		PlatformInfo: platformInfo,
		Commands:     []Command{},
	}

	// Convert job timings to commands format
	for _, job := range jobTimings {
		for _, filename := range job.Files {
			command := Command{
				Name: job.Name,
				Cwd:  ".",
				Ts: CommandTiming{
					Start: job.StartTime,
					End:   job.EndTime,
				},
				Output: filename,
			}
			if job.Status == "failed" {
				command.RetCode = 1
			}
			manifest.Commands = append(manifest.Commands, command)
		}
	}

	return json.MarshalIndent(manifest, "", "  ")
}
